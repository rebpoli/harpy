// MapStore.hpp
#pragma once
using namespace std;

#include <map>
#include <set>
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>

#include <boost/serialization/access.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/set.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/mpi.hpp>

namespace mpi  = boost::mpi;
namespace ser  = boost::serialization;
namespace arch = boost::archive;

using uint = unsigned int;

// ---- Example payload ----
struct MyStruct
{
  string name;
  double value = 0.0;

private:
  friend class ser::access;
  template<class Ar>
  void serialize(Ar& ar, const unsigned /*version*/)
  {
    ar & name & value;
  }
};

// ---------- Generic MPI mixin for any MapT (header-only) ----------
template<class MapT>
struct MpiFileOps
{
  mpi::communicator comm;

  MpiFileOps() : comm() {}

  // Tags
  enum { TAG_MAP = 100, TAG_OK = 101, TAG_KEYS = 102 };

  // API
  void save(const string& path) const;
  void load(const string& path);
  void load(const string& path, const set<typename MapT::key_type>& local_keys);

private:
  friend class ser::access;
  template<class Ar>
  void serialize(Ar& ar, const unsigned /*version*/);

  // Helpers
  void assign_key_by_key(MapT& dst, const MapT& src) const;
  MapT slice_by_keys(const MapT& m, const set<typename MapT::key_type>& keys) const;
  void write_file(const string& path, const MapT& m) const;
  void read_file(const string& path, MapT& m) const;
};

// ---------- Final MapStore ----------
using base_map = map<uint, vector<MyStruct>>;

struct MapStore
  : public base_map,
    public MpiFileOps<base_map>
{
  using base_map::base_map; // optional convenience
};

// =========================
// Template IMPLEMENTATIONS
// =========================

/**
  *
**/
template<class MapT>
template<class Ar>
void MpiFileOps<MapT>::serialize(Ar& ar, const unsigned /*version*/)
{
  ar & ser::base_object<MapT>(*this);
}

/**
  *
**/
template<class MapT>
void MpiFileOps<MapT>::save(const string& path) const
{
  const int rank   = comm.rank();
  const int nprocs = comm.size();
  auto const& self = static_cast<MapT const&>(*this);

  if (nprocs == 1)
  {
    this->write_file(path, self);
    return;
  }

  if (rank == 0)
  {
    MapT merged = self;
    for (int src = 1; src < nprocs; ++src)
    {
      MapT shard;
      comm.recv(src, TAG_MAP, shard);
      merged.insert(shard.begin(), shard.end());
    }

    int ok = 1;
    try
    {
      this->write_file(path, merged);
    }
    catch (...)
    {
      ok = 0;
    }

    for (int dst = 1; dst < nprocs; ++dst)
      comm.send(dst, TAG_OK, ok);

    if (!ok)
      throw runtime_error("MapStore::save: root failed to write");
  }
  else
  {
    comm.send(0, TAG_MAP, self);
    int ok = 0;
    comm.recv(0, TAG_OK, ok);
    if (!ok)
      throw runtime_error("MapStore::save: root reported write failure");
  }
}

/**
  *
**/
template<class MapT>
void MpiFileOps<MapT>::load(const string& path)
{
  const int rank   = comm.rank();
  const int nprocs = comm.size();
  auto& self       = static_cast<MapT&>(*this);

  if (nprocs == 1)
  {
    MapT full;
    this->read_file(path, full);
    this->assign_key_by_key(self, full);
    return;
  }

  if (rank == 0)
  {
    MapT full;
    this->read_file(path, full);
    this->assign_key_by_key(self, full);

    for (int dst = 1; dst < nprocs; ++dst)
      comm.send(dst, TAG_MAP, full);
  }
  else
  {
    MapT tmp;
    comm.recv(0, TAG_MAP, tmp);
    this->assign_key_by_key(self, tmp);
  }
}

/**
  *
**/
template<class MapT>
void MpiFileOps<MapT>::load(const string& path,
                            const set<typename MapT::key_type>& local_keys)
{
  using K = typename MapT::key_type;
  const int rank   = comm.rank();
  const int nprocs = comm.size();
  auto& self       = static_cast<MapT&>(*this);

  if (nprocs == 1)
  {
    MapT full;
    this->read_file(path, full);
    MapT slice = this->slice_by_keys(full, local_keys);
    this->assign_key_by_key(self, slice);
    return;
  }

  if (rank == 0)
  {
    MapT full;
    this->read_file(path, full);
    MapT my_slice = this->slice_by_keys(full, local_keys);
    this->assign_key_by_key(self, my_slice);

    for (int src = 1; src < nprocs; ++src)
    {
      set<K> req;
      comm.recv(src, TAG_KEYS, req);
      MapT slice = this->slice_by_keys(full, req);
      comm.send(src, TAG_MAP, slice);
    }
  }
  else
  {
    comm.send(0, TAG_KEYS, local_keys);
    MapT slice;
    comm.recv(0, TAG_MAP, slice);
    this->assign_key_by_key(self, slice);
  }
}

/**
  *
**/
template<class MapT>
void MpiFileOps<MapT>::assign_key_by_key(MapT& dst, const MapT& src) const
{
  dst.clear();
  for (const auto& kv : src)
    dst.insert(kv);
}

/**
  *
**/
template<class MapT>
MapT MpiFileOps<MapT>::slice_by_keys(const MapT& m,
                                     const set<typename MapT::key_type>& keys) const
{
  MapT out;
  for (const auto& k : keys)
  {
    auto it = m.find(k);
    if (it != m.end())
      out.insert(*it);
  }
  return out;
}

/**
  *
**/
template<class MapT>
void MpiFileOps<MapT>::write_file(const string& path, const MapT& m) const
{
  ofstream ofs(path, ios::binary);
  if (!ofs)
    throw runtime_error("MapStore::save: cannot open " + path);
  arch::binary_oarchive oa(ofs);
  oa << m;
}

/**
  *
**/
template<class MapT>
void MpiFileOps<MapT>::read_file(const string& path, MapT& m) const
{
  ifstream ifs(path, ios::binary);
  if (!ifs)
    throw runtime_error("MapStore::load: cannot open " + path);
  arch::binary_iarchive ia(ifs);
  ia >> m;
}





src/material/ViscoplasticIFC.cpp|73 col 13| required from here
include/util/MpiFileOps.h|75 col 22| error: invalid ‘static_cast’ from type ‘const MpiFileOps<std::map<unsigned int, std::vector<InitVPProps> > >’ to type ‘const std::map<unsigned int, std::vector<InitVPProps> >&’
||    78 |   auto const& self = static_cast<MapT const&>(*this);
