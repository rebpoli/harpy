// MpiFileOps.hpp (header-only)
#pragma once
using namespace std;

#include <map>
#include <set>
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>

#include <boost/serialization/access.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/set.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/mpi.hpp>

namespace mpi  = boost::mpi;
namespace ser  = boost::serialization;
namespace arch = boost::archive;

using uint = unsigned int;

// ---- Example payload ----
struct MyStruct
{
  string name;
  double value = 0.0;

private:
  friend class ser::access;
  template<class Ar>
  void serialize(Ar& ar, const unsigned /*version*/)
  {
    ar & name & value;
  }
};

// ---------- Generic MPI mixin using CRTP (header-only) ----------
template<class Derived>
struct MpiFileOps
{
  using MapT = typename Derived::base_map;

  // public communicator
  mpi::communicator comm;

  MpiFileOps() : comm() {}

  // Tags
  enum { TAG_MAP = 100, TAG_OK = 101, TAG_KEYS = 102 };

  // API
  void save(const string& path) const;
  void load(const string& path);
  void load(const string& path, const set<typename MapT::key_type>& local_keys);

private:
  friend class ser::access;

  /**
    *
  **/
  template<class Ar>
  void serialize(Ar& ar, const unsigned /*version*/)
  {
    // serialize the MapT base subobject of the most-derived
    ar & ser::base_object<MapT>(static_cast<Derived&>(*this));
  }

  // Helpers
  void assign_key_by_key(MapT& dst, const MapT& src) const;
  MapT slice_by_keys(const MapT& m, const set<typename MapT::key_type>& keys) const;
  void write_file(const string& path, const MapT& m) const;
  void read_file(const string& path, MapT& m) const;
};

// ---------- Final MapStore ----------
using base_map = map<uint, vector<MyStruct>>;

struct MapStore
  : public base_map,
    public MpiFileOps<MapStore>
{
  using base_map::base_map; // optional convenience
};

// =========================
// Template IMPLEMENTATIONS
// =========================

/**
  *
**/
template<class Derived>
void MpiFileOps<Derived>::save(const string& path) const
{
  const int rank   = comm.rank();
  const int nprocs = comm.size();

  // Derived is-a MapT, so this cast is valid
  auto const& self = static_cast<Derived const&>(*this);
  auto const& self_map = static_cast<MapT const&>(self);

  if (nprocs == 1)
  {
    this->write_file(path, self_map);
    return;
  }

  if (rank == 0)
  {
    MapT merged = self_map;
    for (int src = 1; src < nprocs; ++src)
    {
      MapT shard;
      comm.recv(src, TAG_MAP, shard);
      // First-wins policy; replace with concatenation if desired.
      merged.insert(shard.begin(), shard.end());
    }

    int ok = 1;
    try
    {
      this->write_file(path, merged);
    }
    catch (...)
    {
      ok = 0;
    }

    for (int dst = 1; dst < nprocs; ++dst)
    {
      comm.send(dst, TAG_OK, ok);
    }

    if (!ok)
    {
      throw runtime_error("MapStore::save: root failed to write");
    }
  }
  else
  {
    comm.send(0, TAG_MAP, self_map);
    int ok = 0;
    comm.recv(0, TAG_OK, ok);
    if (!ok)
    {
      throw runtime_error("MapStore::save: root reported write failure");
    }
  }
}

/**
  *
**/
template<class Derived>
void MpiFileOps<Derived>::load(const string& path)
{
  const int rank   = comm.rank();
  const int nprocs = comm.size();

  auto& self     = static_cast<Derived&>(*this);
  auto& self_map = static_cast<MapT&>(self);

  if (nprocs == 1)
  {
    MapT full;
    this->read_file(path, full);
    this->assign_key_by_key(self_map, full);
    return;
  }

  if (rank == 0)
  {
    MapT full;
    this->read_file(path, full);
    this->assign_key_by_key(self_map, full);

    for (int dst = 1; dst < nprocs; ++dst)
    {
      comm.send(dst, TAG_MAP, full);
    }
  }
  else
  {
    MapT tmp;
    comm.recv(0, TAG_MAP, tmp);
    this->assign_key_by_key(self_map, tmp);
  }
}

/**
  *
**/
template<class Derived>
void MpiFileOps<Derived>::load(
  const string& path,
  const set<typename MapT::key_type>& local_keys)
{
  using K = typename MapT::key_type;

  const int rank   = comm.rank();
  const int nprocs = comm.size();

  auto& self     = static_cast<Derived&>(*this);
  auto& self_map = static_cast<MapT&>(self);

  if (nprocs == 1)
  {
    MapT full;
    this->read_file(path, full);
    MapT slice = this->slice_by_keys(full, local_keys);
    this->assign_key_by_key(self_map, slice);
    return;
  }

  if (rank == 0)
  {
    MapT full;
    this->read_file(path, full);

    MapT my_slice = this->slice_by_keys(full, local_keys);
    this->assign_key_by_key(self_map, my_slice);

    for (int src = 1; src < nprocs; ++src)
    {
      set<K> req;
      comm.recv(src, TAG_KEYS, req);
      MapT slice = this->slice_by_keys(full, req);
      comm.send(src, TAG_MAP, slice);
    }
  }
  else
  {
    comm.send(0, TAG_KEYS, local_keys);
    MapT slice;
    comm.recv(0, TAG_MAP, slice);
    this->assign_key_by_key(self_map, slice);
  }
}

/**
  *
**/
template<class Derived>
void MpiFileOps<Derived>::assign_key_by_key(MapT& dst, const MapT& src) const
{
  dst.clear();
  for (const auto& kv : src)
  {
    dst.insert(kv);
  }
}

/**
  *
**/
template<class Derived>
typename MpiFileOps<Derived>::MapT
MpiFileOps<Derived>::slice_by_keys(const MapT& m,
                                   const set<typename MapT::key_type>& keys) const
{
  MapT out;
  for (const auto& k : keys)
  {
    auto it = m.find(k);
    if (it != m.end())
    {
      out.insert(*it);
    }
  }
  return out;
}

/**
  *
**/
template<class Derived>
void MpiFileOps<Derived>::write_file(const string& path, const MapT& m) const
{
  ofstream ofs(path, ios::binary);
  if (!ofs)
  {
    throw runtime_error("MapStore::save: cannot open " + path);
  }
  arch::binary_oarchive oa(ofs);
  oa << m;
}

/**
  *
**/
template<class Derived>
void MpiFileOps<Derived>::read_file(const string& path, MapT& m) const
{
  ifstream ifs(path, ios::binary);
  if (!ifs)
  {
    throw runtime_error("MapStore::load: cannot open " + path);
  }
  arch::binary_iarchive ia(ifs);
  ia >> m;
}

